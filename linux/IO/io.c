#include <stdio.h>
#include <unistd.h>

void fun(){
    while(1){
        write(STDOUT_FILENO,"1",1);
        sleep(1);
    }
}
void fun1(){
    while (1)
    {
        printf("123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910123456789101234567891012345678910");
        sleep(1);
    }
    
}
int main(){

    /*
    fun()一个一个打印
    fun1()一块一块打印
    */
    char message[]="hello";
    printf("%s",message);
    sleep(3);
    write(STDOUT_FILENO,"world",6);
    sleep(3);
    printf("刷新缓冲区\n");
}
/*
linux中系统调用需要进程由用户态转向内核态完成系统调用后再返回这个过程中会消耗一定的资源
为了减少状态的转换，linux中在一些文件IO的库函数中植入了预读入缓读出机制，仅当刷新缓冲区或缓冲区满的时候进行系统调用进行文件IO
实际业务中如果大量使用系统调用会有大量的切换过程，因而对一些数据同步要求不太严格的情景应该使用库函数替代系统调用
同时使用库函数的时候也要注意缓冲区的存在，可以使用\n及时的刷新缓冲区
linux中缓冲区的大小默认是1024
*/